#!/usr/bin/env node
global.cli   = require('commander');
var moment   = require('moment');
var Q        = require('q');
var util     = require('util');
var Helpers  = require('../lib/helpers');
var Timer    = require('../lib/timer');
var Print    = require('../lib/print');
var Landing  = require('../lib/landing');
var Tmux     = require('../lib/tmux');
var Logger   = require('../lib/logger');

var speak    = Helpers.speak;
var growl    = Helpers.growl;
var clear    = Helpers.clear;
var duration = Helpers.duration;
var format   = util.format;

var work, snack;

Q.longStackSupport = true;

cli
  .usage('[reason]')
  .version(require('../package').version)
  .option('-w, --work [mins]', 'work timer length [25]', 25)
  .option('-b, --break [mins]', 'break timer length, 0 to disable [5]', 5)
  .option('-d, --duration [mins]', 'shortcut for -w <secs> -b 0', null)
  .option('-t, --tmux', 'enable tmux reporting')
  .option('-l, --log [file]', 'log to this file')
  .option('-q, --quiet', 'no sounds')
  .on('--help', function() {
    console.log('  examples:');
    console.log('');
    console.log('    $ pomojs                # start a timer');
    console.log('    $ pomojs "Fix stuff"    # reason');
    console.log('    $ pomojs -w 10          # 10-minute pomodoro');
    console.log('    $ pomojs -d 5 "Tea"     # Simple tea timer (no break)');
  })
  .parse(process.argv);

var reason = cli.args.join(' ') || 'work';
var total  = { start: new Date(), end: null };
var reporters = [ Landing ];

if (cli.tmux) { reporters.push(Tmux); }
if (cli.duration) { cli.work = cli.duration; cli.break = 0; }

var say = function(words) {
  if (!cli.quiet) speak(words);
  growl(words);
};

Q.try(function() {
  work  = new Timer(cli.work,  { mode: 'work',  say: say, progress: reporters });
  snack = new Timer(cli.break, { mode: 'break', say: say, progress: reporters });

}).then(function() {
  clear();

  say(format("%s, %s for %s", 
     moment().format("h:mm a"), work.duration.humanize(), reason));

  if (cli.break > 0) {
    Print.now(format("time for %s (%s)\na %s break follows",
      reason, duration(work.duration), duration(snack.duration)));
  } else {
    Print.now(format("time for %s (%s)",
      reason, duration(work.duration)));
  }

  work.initial();
  return Q.delay(1000);

}).then(function() {
  return work.start();

}).then(function() {
  if (cli.break <= 0) return;

  say(format("Done! %s, break for %s",
    moment().format("hh:mm a"), snack.duration.humanize()));

  Print.now(format("time for a break (%s)",
    duration(snack.duration)));

  snack.initial();

  return Q.delay(3000)
  .then(function() {
    total.end = new Date();
    return snack.start();
  });

}).then(function() {
  say(reason + ": all done!");
  Print.now("done");
  work.abort();
  logEntry();

}).done();

/**
 * It's a trap.
 */

process.on('SIGINT', function() {
  console.log("");
  work.abort();
  Print.now('interrupted');
  logEntry(true);
  process.exit(0);
});

/**
 * Logs the current entry.
 */

function logEntry(interrupted) {
  if (!cli.log) return;
  Logger(cli.log, {
    reason: reason,
    duration: work.elapsed(),
    'break': snack.elapsed(),
    interrupted: !!interrupted
  });
}

